# Vanilla Buffer Overflows

## Things to remember
  *  Maintain format determined during initial analysis/fuzzing
  *  Double check bad characters by hand

## Useful tools
  *  [`Immunity Debugger`](https://www.immunityinc.com/products/debugger/)/[`WinDbg`](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/) for observing memory/register contents
  *  [`msf-pattern_create`](https://www.kali.org/tools/metasploit-framework/#msf-pattern_create)/[`msf-pattern_offset`](https://www.kali.org/tools/metasploit-framework/#msf-pattern_offset) of [MSF](https://docs.metasploit.com/) for finding instruction pointer offset
  *  [`mona.py`](https://github.com/corelan/mona) for various automations during exploit development (mostly 32-bit)
  *  [`msf-metasm_shell`](https://www.kali.org/tools/metasploit-framework/#msf-metasm_shell) of [MSF](https://docs.metasploit.com/) for generating opcode values
  *  [`msfvenom`](https://www.kali.org/tools/metasploit-framework/#msfvenom) of [MSF](https://docs.metasploit.com/) for generating payloads

## Instruction pointer offset
  *  `MSF` for finding bytes between message start and overwriting of instruction pointer
  *  Send a cyclic pattern in order to easily calculate the offset
      *  Use custom pattern sets to avoid bad characters
      *  Repeat characters will occur more frequently with smaller character sets
      *  Making the pattern larger than the crash bytes helps determine space to work with

```
echo "USER $(msf-pattern_create -l 1000)" | nc -nv 10.0.0.1 9999
```

// Produces repeat characters after a number of cycles
```
msf-pattern_create -l 1000
msf-pattern_offset -l 1000 -q DEADBEEF
```

// Produces repeat characters after a much smaller number of cycles
```
msf-pattern_create -l 1000 -s BCD,bcd,234
msf-pattern_offset -l 1000 -s BCD,bcd,234 -q DEADBEEF
```

## Bad characters
  *  `mona.py` can identify byte values that mangle/corrupt the intended data structure
      *  Generate all possible byte values with python oneliner
      *  Feed list of potential bad bytes in place of payload
  *  Maintain the structure of the buffer as the exploit develops
      *  Fill in return address `retn` with an arbitrary value e.g. `BBBB`
      *  Pad message to match length of baseline fuzzing messages

```
python3 -c "for i in range(1, 256): print('\\\\x{:02x}'.format(i), end='')"
```

```
!mona config -set workingfolder c:\mona
!mona bytearray -cpb "\x00"
!mona compare -f c:\mona\bytearray.bin -a [address of bytes]
```

## Repositioning
  *  Hunt for addresses to place into the instruction pointer
      *  `JMP ESP` is the most common example but may not always be viable
      *  Watch for useful register contents e.g. stack-aligned addresses
      *  Addresses containing bad characters must be avoided
  *  `mona.py` for automatically searching for `JMP` instructions
      *  `msf-metasm_shell` for generating specific opcodes to search for

```
!mona jmp -r esp
!mona jmp -r esp -cbp "\x00"
```

```
metasm > jmp esp
!mona modules
!mona find -s "\xff\xe4" -m example.dll
```

## Proof of concept
  *  Modify `exploit.py` with information gathered  
  *  `msfvenom` for generating shellcode for various payloads
      *  Use encoders to avoid bad characters in shellcode
      *  Prepend payload with a nopsled when an encoder is used
