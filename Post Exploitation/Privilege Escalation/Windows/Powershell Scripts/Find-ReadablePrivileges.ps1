Add-Type @"
using System;
using System.Runtime.InteropServices;
using System.Text;

public class Win32
{
    [DllImport("kernel32.dll")]
    public static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, uint dwProcessId);

    [DllImport("kernel32.dll")]
    public static extern bool CloseHandle(IntPtr hObject);

    [DllImport("advapi32.dll")]
    public static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);

    [DllImport("advapi32.dll")]
    public static extern bool GetTokenInformation(IntPtr TokenHandle, int TokenInformationClass, IntPtr TokenInformation, uint TokenInformationLength, out uint ReturnLength);

    [DllImport("advapi32.dll", CharSet=CharSet.Auto)]
    public static extern bool LookupPrivilegeName(string lpSystemName, ref LUID lpLuid, StringBuilder lpName, ref uint cchName);

    [StructLayout(LayoutKind.Sequential)]
    public struct LUID
    {
        public uint LowPart;
        public int HighPart;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct LUID_AND_ATTRIBUTES
    {
        public LUID Luid;
        public uint Attributes;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct TOKEN_PRIVILEGES
    {
        public uint PrivilegeCount;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=35)]
        public LUID_AND_ATTRIBUTES[] Privileges;
    }

    public const uint TokenPrivileges = 3;
    public const uint TOKEN_QUERY = 0x0008;
    public const uint PROCESS_QUERY_INFORMATION = 0x0400;
    public const uint SE_PRIVILEGE_ENABLED = 0x00000002;
}
"@

function Find-ReadablePrivileges() {
    <#
    .Synopsis
    Gather privileges held by readable process tokens. Exclusion takes precedence over inclusion.
    .Parameter ExcludeSessions
    Array of session IDs to ignore
    .Parameter ExcludePIDs
    Array of process IDs to ignore
    .Parameter ExcludeNames
    Array of process names to ignore
    .Parameter IncludeSessions
    Array of session IDs to enumerate
    .Parameter IncludePIDs
    Array of process IDs to enumerate
    .Parameter IncludeNames
    Array of process names to enumerate
    .Example
    PS> Find-ReadablePrivileges -ExcludeSessions (0,1)
    .Example
    PS> Find-ReadablePrivileges -ExcludePIDs ($PID)
    .Example
    PS> Find-ReadablePrivileges -ExcludeNames ("lsass")
    #>
    param (
        [Parameter(HelpMessage="Array of session IDs to ignore")]
        [int[]]
        $ExcludeSessions,
        [Parameter(HelpMessage="Array of process IDs to ignore")]
        [int[]]
        $ExcludePIDs,
        [Parameter(HelpMessage="Array of process names to ignore")]
        [string[]]
        $ExcludeNames,
        [Parameter(HelpMessage="Array of session IDs to enumerate")]
        [int[]]
        $IncludeSessions,
        [Parameter(HelpMessage="Array of process IDs to enumerate")]
        [int[]]
        $IncludePIDs,
        [Parameter(HelpMessage="Array of process names to enumerate")]
        [string[]]
        $IncludeNames
    )

    $processes = Get-Process |
    Where-Object {$_.SI -notin $ExcludeSessions} |
    Where-Object {$_.Id -notin $ExcludePIDs} |
    Where-Object {$_.ProcessName -notin $ExcludeNames} |
    Where-Object {($_.SI -In $IncludeSessions) -or ($IncludeSessions -eq $null)} |
    Where-Object {($_.Id -In $IncludePIDs) -or ($IncludePIDs -eq $null)} |
    Where-Object {($_.ProcessName -In $IncludeNames) -or ($IncludeNames -eq $null)}

    foreach ($process in $processes) {
        $processHandle = [Win32]::OpenProcess([Win32]::PROCESS_QUERY_INFORMATION, $false, $process.Id)
        if ($processHandle -eq 0) {
            continue
        }

        $tokenHandle = [IntPtr]::Zero
        if ([Win32]::OpenProcessToken($processHandle, [Win32]::TOKEN_QUERY, [ref]$tokenHandle) -eq 0) {
            $_ = [Win32]::CloseHandle($processHandle)
            continue
        }

        $tokenPrivilegesBufferSize = 0
        $_ = [Win32]::GetTokenInformation($tokenHandle, [Win32]::TokenPrivileges, [IntPtr]::Zero, 0, [ref]$tokenPrivilegesBufferSize)
        $tokenPrivilegesBuffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($tokenPrivilegesBufferSize)
        if([Win32]::GetTokenInformation($tokenHandle, [Win32]::TokenPrivileges, $tokenPrivilegesBuffer, $tokenPrivilegesBufferSize, [ref]$tokenPrivilegesBufferSize) -eq 0) {
            [System.Runtime.InteropServices.Marshal]::FreeHGlobal($tokenPrivilegesBuffer)
            $_ = [Win32]::CloseHandle($tokenHandle)
            $_ = [Win32]::CloseHandle($processHandle)
            continue
        }

        $tokenPrivileges = [System.Runtime.InteropServices.Marshal]::PtrToStructure($tokenPrivilegesBuffer, [Type][Win32+TOKEN_PRIVILEGES])
        for ($i = 0; $i -lt $tokenPrivileges.PrivilegeCount; $i++) {
            $name = New-Object System.Text.StringBuilder 256
            $luid = $tokenPrivileges.Privileges[$i].Luid
            if ([Win32]::LookupPrivilegeName($null, [ref]$luid, $name, [ref]256) -ne 0) {
                Add-Member -InputObject $process -NotePropertyName Privilege -NotePropertyValue $name.ToString() -Force
            } else {
                Add-Member -InputObject $process -NotePropertyName Privilege -NotePropertyValue "ERR" -Force
            }

            $attributes = $tokenPrivileges.Privileges[$i].Attributes
            if (($attributes -band [Win32]::SE_PRIVILEGE_ENABLED) -eq [Win32]::SE_PRIVILEGE_ENABLED) {
                Add-Member -InputObject $process -NotePropertyName Status -NotePropertyValue "Enabled" -Force
            } else {
                Add-Member -InputObject $process -NotePropertyName Status -NotePropertyValue "Disabled" -Force
            }

            $process | Select-Object -Property ProcessName, Path, Id, Privilege, Status
        }

        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($tokenPrivilegesBuffer)
        $_ = [Win32]::CloseHandle($tokenHandle)
        $_ = [Win32]::CloseHandle($processHandle)
    }
}
