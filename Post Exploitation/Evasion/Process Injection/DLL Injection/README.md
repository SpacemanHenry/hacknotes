# Vanilla DLL Injection

## Things to remember
  *  [CsWin32](https://github.com/microsoft/CsWin32) used to generate P/Invoke definitions for simplicity
  *  ired.team has a [page covering this](https://www.ired.team/offensive-security/code-injection-process-injection/dll-injection)
  *  This method involves writing a DLL file to disk on the target
      *  This is generally not a good idea, consider on-disk evasion methods
  *  `CreateRemoteThread` used to force target process to invoke [`LoadLibrary`](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya)

## How it works  
  *  Compile DLL with custom entry-point code using `go`
  *  Drop custom DLL on target filesystem
  *  Allocate memory in target process matching file path size
  *  Write DLL file path to target process memory
  *  Resolve address of LoadLibraryA function
  *  Spawn new thread in target process pointing to LoadLibraryA address
      *  Pass memory address containing DLL path as parameter

## Compilation 
  *  For C# code, open project with `Visual Studio` and compile for target architecture
  *  For Go code, `go env` must be modified to cross-compile as DLL for windows
      *  Manually change `GOOS`, `GOARCH`, and `CC` using `go env`
      *  `CC` is the compiler to use for [`cgo`](https://go.dev/blog/cgo) code
  *  In order to compile `cgo` code for windows, a C cross-compiler is needed
      *  `i686-w64-mingw32-gcc` or `x86_64-w64-mingw32-gcc` depending on architecture

```
go env -w GOOS=windows
go env -w GOARCH=amd64
go env -w CC=x86_64-w64-mingw32-gcc
go build -o custom.dll -buildmode=c-shared main.go
```
