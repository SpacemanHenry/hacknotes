# Process Hollowing

## Things to remember
  *  [CsWin32](https://github.com/microsoft/CsWin32) used to generate P/Invoke definitions for simplicity
  *  ired.team has a [page covering this](https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations)
  *  This method is essentially inserting a [PE image](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format) into memory of a sacrificial process
      *  This avoids on-disk signatures for the payload
      *  As always choose payloads wisely, behavioral detections will bite you
  *  [`NtQueryInformationProcess`](https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess) used to query [PEB](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm) base address
  *  [`ZwUnmapViewOfSection`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwunmapviewofsection) used to free memory of target PE image
  *  This implementation targets x64 only, modifications are needed for x86

## How it works
  *  Compile or generate payload EXE file
  *  Create suspended and detached process
  *  Find and zero the image that was already loaded by the OS
  *  Write payload image headers/sections into process memory
  *  Process [relocation table](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#the-reloc-section-image-only) to correct for non-preferred image base address
  *  Update entry point address in the main thread context
  *  Resume process to complete initialization and begin execution

## Compilation 
  *  For C# code, open project with `Visual Studio` and compile for target architecture
  *  `msfvenom` EXEs work out-of-the-box
  *  Custom code should be compiled to EXE and packed (tested with `upx`)
      *  Unpacking stubs operate in-memory which simplifies the initial loading process
      *  Custom code allows finer control over potential red-flag behavior patterns

## Improvements
  *  Consider infiltrating and injecting the payload image in chunks
      *  This avoids in-memory payload signatures outside the victim process
      *  Choose infiltration methods carefully, consider multiple channels
  *  Consider using [alternative memory insertion](https://www.ired.team/offensive-security/code-injection-process-injection/ntcreatesection-+-ntmapviewofsection-code-injection) techniques
      *  Payload memory [section](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views) would mimic the [permissions](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatesection)/[flags](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga) of those created by the OS
      *  This avoids `RWX` memory page permissions from attracting attention
