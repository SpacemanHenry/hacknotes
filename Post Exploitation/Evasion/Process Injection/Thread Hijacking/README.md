# Thread Hijacking

## Things to remember
  *  This program utilizes the [`windows`](https://pkg.go.dev/golang.org/x/sys/windows) package for simplicity where applicable
      *  Some structs lifted from [`golang-win32`](https://pkg.go.dev/github.com/0xrawsec/golang-win32) for manual P/Invokes
  *  ired.team has a [page covering this](https://www.ired.team/offensive-security/code-injection-process-injection/injecting-to-remote-process-via-thread-hijacking)
  *  This method of thread hijacking is common and likely to be detected without modification
  *  `GetThreadTimes` and `NtQueryInformationThread` used to identify valid target threads
      *  Determine modules that spawn critical threads, add these to the blacklist
      *  Module and thread information used to infer which threads belong to which module

## How it works  
  *  Enumerate module and thread information
  *  Compare with blacklist to infer valid target threads
  *  Allocate memory in target process matching shellcode size
  *  Write shellcode bytes to allocated memory
  *  Suspend target thread
  *  Change thread context so instruction pointer points to shellcode
  *  Resume thread to execute shellcode

## Compilation  
  *  Easy to cross-compile for windows from linux using `go`
  *  Always replace the payload, and mind the architecture! (duh)
  *  Change the `PID` value within the `const` block before deployment

```
GOOS=windows GOARCH=amd64 go build -o ThreadHijack.exe main.go
GOOS=windows GOARCH=386 go build -o ThreadHijack.exe main.go
```
