import errno
import socket
import struct
import select
import threading

DEFAULT_CLIENT_TIMEOUT = 10 # seconds
POLL_TIMEOUT = 100 # milliseconds
RECV_SIZE = 1024

# SOCKS5 constants
VERSION = 0x05
RESERVED = 0x00
METHOD_NONE_ACCEPTABLE = 0xFF
METHOD_NO_AUTH = 0x00
METHOD_USER_PASS = 0x02
METHOD_USER_PASS_VERSION = 0x01
CMD_CONNECT = 0x01
ATYP_IPV4 = 0x01
ATYP_DOMAINNAME = 0x03
REP_SUCCESS = 0x00
REP_GENERAL_ERR = 0x01
REP_NOT_ALLOWED = 0x02
REP_NET_UNREACHABLE = 0x03
REP_HOST_UNREACHABLE = 0x04
REP_CONN_REFUSED = 0x05
REP_CMD_UNSUPPORTED = 0x07
REP_ATYP_UNSUPPORTED = 0x08
REP_INCORRECT_VERSION = 0x09
REP_CLIENT_UNAVAILABLE = 0x0a
REP_USER_PASS_SUCCESS = 0x00
REP_USER_PASS_FAILURE = 0x0b

class Proxy():
        def __init__(self, lhost, lport, timeout=DEFAULT_CLIENT_TIMEOUT, username=None, password=None):
                self.lhost = lhost
                self.lport = lport
                self.timeout = timeout

                self.auth = False
                if username != None or password != None:
                        self.auth = True
                        self.username = '' if username is None else str(username)
                        self.password = '' if password is None else str(password)

                self.exit = threading.Event()

        class PollError(Exception):
                pass

        class SOCKSError(Exception):
                def __init__(self, message, errno):
                        super().__init__(message)
                        self.errno = errno

        def poll(self, conn):
                fd = conn.fileno()
                poll = select.poll()
                poll.register(fd, select.POLLIN)
                job = dict(poll.poll(POLL_TIMEOUT))
                if len(job) != 0 and job[fd] != select.POLLIN:
                        raise self.PollError(fd, job[fd], 'Unexpected poll result')

                return job

        def forward(self, i, o, disconnected):
                while not self.exit.is_set() and not disconnected.is_set():
                        try:
                                job = self.poll(i)
                                if len(job) == 0:
                                        continue

                                data = i.recv(1024)
                                if not data:
                                        break

                                o.send(data)
                        except (self.PollError, OSError, ValueError) as e:
                                print('Connection status change detected: %s' %(repr(e)))
                                break
                        except Exception as e:
                                print('Unexpected failure: %s' %(repr(e)))
                                break

                try:
                        disconnected.set()
                        i.shutdown(socket.SHUT_RDWR)
                except OSError as e:
                        print('Connection shutdown failed: %s' %(repr(e)))
                except Exception as e:
                        print('Unexpected failure: %s' %(repr(e)))
                finally:
                        i.close()

        def negotiate(self, client):
                greeting = client.recv(RECV_SIZE)
                version, nmethods = struct.unpack('!BB', greeting[:2])
                if version != VERSION:
                        raise self.SOCKSError('Client gave incorrect SOCKS version', REP_INCORRECT_VERSION)

                methods = struct.unpack('!%iB' %(nmethods), greeting[2:])
                if METHOD_USER_PASS in methods and self.auth:
                        method = METHOD_USER_PASS
                elif METHOD_NO_AUTH in methods and not self.auth:
                        method = METHOD_NO_AUTH
                else:
                        raise self.SOCKSError('Client gave no acceptable authentication methods', METHOD_NONE_ACCEPTABLE)

                response = struct.pack('!BB', VERSION, method)
                client.send(response)
                return method

        def authenticate(self, client, method):
                if method == METHOD_NO_AUTH:
                        return

                auth = client.recv(RECV_SIZE)
                version = auth[0]
                if version != METHOD_USER_PASS_VERSION:
                        raise self.SOCKSError('Client gave incorrect auth version', REP_INCORRECT_VERSION)

                ulen = auth[1]
                username = auth[2:2 + ulen].decode()
                plen = auth[2 + ulen]
                password = auth[2 + ulen + 1:2 + ulen + 1 + plen].decode()
                if username == self.username and password == self.password:
                        response = struct.pack('!BB', METHOD_USER_PASS_VERSION, REP_USER_PASS_SUCCESS)
                        client.send(response)
                        return
                else:
                        raise self.SOCKSError('Client failed authentication', REP_USER_PASS_FAILURE)

        def parse(self, request):
                version, cmd, rsv, atyp = struct.unpack('!4B', request[:4])
                if cmd != CMD_CONNECT:
                        raise self.SOCKSError('Client gave unsupported command', REP_CMD_UNSUPPORTED)

                if atyp == ATYP_IPV4:
                        rhost = '.'.join([str(n) for n in struct.unpack('!4B', request[4:8])])
                        rport = struct.unpack('!H', request[8:])[0]
                elif atyp == ATYP_DOMAINNAME:
                        rlen = request[4]
                        rhost = request[5:5 + rlen].decode()
                        rport = struct.unpack('!H', request[5 + rlen:])[0]
                else:
                        raise self.SOCKSError('Client gave unsupported address', REP_ATYP_UNSUPPORTED)

                return rhost, rport

        def serve(self, client):
                try:
                        method = self.negotiate(client)
                        self.authenticate(client, method)
                        request = client.recv(RECV_SIZE)
                        rhost, rport = self.parse(request)
                        target = socket.socket()
                        target.connect((rhost, rport))
                        servaddr = [int(n) for n in self.lhost.split('.')]
                        response = struct.pack('!8BH', VERSION, REP_SUCCESS, RESERVED, ATYP_IPV4, *servaddr, self.lport)
                        client.send(response)

                except OSError as e:
                        print('Connection open failed: %s' %(repr(e)))
                        if e.errno == errno.ENETUNREACH:
                                errcode = REP_NET_UNREACHABLE
                        elif e.errno == errno.EHOSTUNREACH:
                                errcode = REP_HOST_UNREACHABLE
                        elif e.errno == errno.ECONNREFUSED:
                                errcode = REP_CONN_REFUSED
                        else:
                                errcode = REP_GENERAL_ERR

                        try:
                                servaddr = [int(n) for n in self.lhost.split('.')]
                                response = struct.pack('!8BH', VERSION, errcode, RESERVED, ATYP_IPV4, *servaddr, self.lport)
                                client.send(response)
                        except Exception as e:
                                print('Server error response failed: %s' %(repr(e)))

                        client.close()
                        return

                except self.SOCKSError as e:
                        print('SOCKS5 operation failed: %s' %(repr(e)))
                        # RFC 1928 does not define responses to incorrect version
                        # Testing shows other SOCKS5 proxies FIN/ACK w/o data
                        if e.errno == REP_INCORRECT_VERSION:
                                client.close()
                                return
                        elif e.errno == METHOD_NONE_ACCEPTABLE:
                                response = struct.pack('!BB', VERSION, METHOD_NONE_ACCEPTABLE)
                        elif e.errno == REP_USER_PASS_FAILURE:
                                response = struct.pack('!BB', VERSION, REP_USER_PASS_FAILURE)
                        elif e.errno == REP_CMD_UNSUPPORTED or e.errno == REP_ATYP_UNSUPPORTED:
                                servaddr = [int(n) for n in self.lhost.split('.')]
                                response = struct.pack('!8BH', VERSION, e.errno, RESERVED, ATYP_IPV4, *servaddr, self.lport)

                        try:
                                client.send(response)
                                client.close()
                                return
                        except Exception as e:
                                print('Server error response failed: %s' %(repr(e)))

                except Exception as e:
                        print('Unexpected failure: %s' %(repr(e)))
                        client.close()
                        return

                target.setblocking(False)
                client.setblocking(False)
                disconnected = threading.Event()
                threading.Thread(target=self.forward, args=(client, target, disconnected)).start()
                threading.Thread(target=self.forward, args=(target, client, disconnected)).start()

        def run(self):
                print('Listening on %s:%s' %(self.lhost, self.lport))
                server = socket.socket()
                server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                server.bind((self.lhost, self.lport))
                server.listen()

                while not self.exit.is_set():
                        try:
                                client, addr = server.accept()
                                client.settimeout(self.timeout)
                                threading.Thread(target=self.serve, args=(client,)).start()
                        except KeyboardInterrupt:
                                print('\nShutting down...')
                                break

                server.shutdown(socket.SHUT_RDWR)
                self.exit.set()

if __name__ == '__main__':
        Proxy('0.0.0.0', 1080).run()
