import socket
import select
import logging
import threading

DEFAULT_TIMEOUT = 100 # milliseconds
RECV_SIZE = 1024

class Forwarder():
        def __init__(self, local_host, local_port, remote_host, remote_port, verbose=False, log=None, timeout=DEFAULT_TIMEOUT):
                self.local_host = local_host
                self.local_port = local_port
                self.remote_host = remote_host
                self.remote_port = remote_port
                self.verbose = verbose
                self.timeout = timeout

                if not log:
                        logging.basicConfig(
                                level=logging.INFO,
                                format='%(asctime)s %(levelname)s %(message)s',
                                datefmt='%m/%d/%Y %H:%M'
                        )
                else:
                        logging.basicConfig(
                                level=logging.INFO,
                                format='%(asctime)s %(levelname)s %(message)s',
                                datefmt='%m/%d/%Y %H:%M',
                                handlers=[
                                        logging.FileHandler(log),
                                        logging.StreamHandler()
                                ]
                        )

                self.exit_flag = threading.Event()

        class PollError(Exception):
                pass

        # poll given connection for readable data
        def wait_for_job(self, conn):
                fd = conn.fileno()
                poll = select.poll()
                poll.register(fd, select.POLLIN)
                job = dict(poll.poll(self.timeout))

                if len(job) != 0 and job[fd] != select.POLLIN:
                        raise self.PollError(fd, job[fd], 'Unexpected poll result')

                return job

        # recv data from one connection and send it through another
        def relay(self, input_conn, output_conn, job):
                if len(job) == 0:
                        return False

                data = input_conn.recv(RECV_SIZE)
                if not data:
                        return True

                output_conn.send(data)
                return False

        # wait for jobs, perform relay, and disconnect when appropriate
        # called twice to form bidirectional data flow
        def forward(self, input_conn, output_conn, disconnected_flag):
                # exit flag used to indicate server requesting shutdown
                while not self.exit_flag.is_set():
                        # disconnects both sides of a forward when one side errors
                        if disconnected_flag.is_set():
                                break

                        try:
                                job = self.wait_for_job(input_conn)
                                done = self.relay(input_conn, output_conn, job)
                                if done:
                                        break
                        except (self.PollError, OSError, ValueError) as e:
                                logging.error('Connection status change detected: %s' %(repr(e)))
                                break
                        except Exception as e:
                                logging.error('Unexpected failure: %s' %(repr(e)))
                                break

                try:
                        # set disconnect flag before closing input connection
                        # this forces the corresponding forward thread to close as well
                        disconnected_flag.set()
                        input_conn.shutdown(socket.SHUT_RDWR)
                except OSError as e:
                        logging.error('Connection shutdown failed: %s' %(repr(e)))
                except Exception as e:
                        logging.error('Unexpected failure: %s' %(repr(e)))
                finally:
                        input_conn.close()

        # create a connection to the target for each client
        # create two forwarding threads, one for each direction of data flow
        def serve(self, client, addr):
                if self.verbose:
                        logging.info('Forwarding connection from %s' %(addr,))

                try:
                        target = socket.socket()
                        target.connect((self.remote_host, self.remote_port))
                except OSError as e:
                        logging.error('Connection open failed: %s' %(repr(e)))
                        client.close()
                        return
                except Exception as e:
                        logging.error('Unexpected failure: %s' %(repr(e)))
                        client.close()
                        return

                target.setblocking(False)
                client.setblocking(False)
                disconnected_flag = threading.Event()
                threading.Thread(target=self.forward, args=(client, target, disconnected_flag)).start()
                threading.Thread(target=self.forward, args=(target, client, disconnected_flag)).start()

        # create server socket, accept and serve connections
        def run(self):
                logging.info('Listening on %s:%s' %(self.local_host, self.local_port))
                server = socket.socket()
                server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                server.bind((self.local_host, self.local_port))
                server.listen()

                while not self.exit_flag.is_set():
                        try:
                                client, addr = server.accept()
                                threading.Thread(target=self.serve, args=(client, addr)).start()
                        except KeyboardInterrupt:
                                print('')
                                logging.info('Shutting down...')
                                break

                server.shutdown(socket.SHUT_RDWR)
                self.exit_flag.set()

if __name__ == '__main__':
        import argparse
        parser = argparse.ArgumentParser(prog='portforward.py', description='accept connections on a local port and relay data to a remote port')
        parser.add_argument('local', help='local IP/port to bind to (Ex. 127.0.0.1:4444)')
        parser.add_argument('remote', help='remote IP/port to forward data to (Ex. 127.0.0.1:80)')
        parser.add_argument('-v', '--verbose', help='display all forwarded connections', action='store_true')
        parser.add_argument('-o', '--output', help='log any output to a given file')
        parser.add_argument('-t', '--timeout', help='time to wait for connection activity in milliseconds', default=100, type=int)
        args = parser.parse_args()

        local_host, local_port = args.local.strip().split(':')
        local_port = int(local_port)
        remote_host, remote_port = args.remote.strip().split(':')
        remote_port = int(remote_port)

        forwarder = Forwarder(local_host, local_port, remote_host, remote_port, args.verbose, args.output, args.timeout)
        forwarder.run()
